import yaml, os, re, json, difflib, subprocess, ansible_runner, threading, time, socket
from textwrap import dedent
from subprocess import CalledProcessError
from distutils.version import LooseVersion
from http.server import BaseHTTPRequestHandler, HTTPServer

# loads env_setup.json (config file) with specified file paths
def loadConfig(config_path):    
    with open(config_path, 'r') as file:
        config = json.load(file)  
    config['boxstarter_path'] = os.path.expanduser(config['boxstarter_path'])
    config['boxstarter_remove_adapter_path'] = os.path.expanduser(config['boxstarter_remove_adapter_path'])
    return config

# removes the network adapter from the VM and restarts to have it go into effect
def removeNetworkAdapter(machine):
    # removes network adapter
    command = ['virt-xml', '--remove-device', machine, '--network', 'source=default']
    try:
        result = subprocess.run(command, check=True, capture_output=True, text=True)
        print(result.stdout)
    except subprocess.CalledProcessError as e:
        print('[ERROR]: ', e.stderr)

    # shuts down VM
    command = ['virsh', 'shutdown', machine]
    try:
        result = subprocess.run(command, check=True, capture_output=True, text=True)
        print(result.stdout)
    except subprocess.CalledProcessError as e:
        print('[ERROR]: ', e.stderr)

    # waits for machine to fully shutdown
    time.sleep(60)

    # starts up VM again
    command = ['virsh', 'start', machine]
    try:
        result = subprocess.run(command, check=True, capture_output=True, text=True)
        print(result.stdout)
    except subprocess.CalledProcessError as e:
        print('[ERROR]: ', e.stderr)
       
# generates Ansible playbook to install Chocolatey and Boxstarter and search for Chocolatey packages
def createAnsibleSearchPlaybook(playbook_path, ansible_search_dir_path, software_dicts):
    tasks = [
        {
            'name': 'Ensure C:/temp directory exists',
            'win_file':
            {
                'path': 'C:/temp',
                'state': 'directory'
            }
        },
        {
            'name': 'Install Boxstarter',
            'win_chocolatey': {
                'name': 'boxstarter',
                'state': 'present'
            }
        },
        {
            'name': 'Execute choco search for each software and version',
            'win_shell': f'choco search "{{{{ item.name }}}}" --all-versions > C:/temp/{{{{ item.name }}}}_choco_search_results.txt',
            'register': 'search_results',
            'loop': software_dicts
        },        
        {
            'name': 'Fetch the files from remote machine',
            'fetch': {
                'src': f"C:/temp/{{{{ item.name }}}}_choco_search_results.txt",
                'dest': ansible_search_dir_path,
                'flat': 'yes'
            },
            'loop': software_dicts
        },    
    ]

    playbook = {
        'name': f'Install Choco/Boxstarter and search for packages',
        'hosts': 'cape_clients',
        'tasks': tasks
    }

    with open(playbook_path, 'w') as file:
        yaml.dump([playbook], file)

# generates Ansible playbook to copy Boxstarter script to VM and run it
def createAnsibleInstallPlaybook(playbook_path, boxstarter_path, remote_boxstarter_path, boxstarter_remove_adapter_path, remote_boxstarter_remove_adapter_path, powershell_script_path, remote_powershell_script_path):
    tasks = [
        {
            'name': 'Copy Boxstarter install package to target machine',
            'win_copy': {
                'src': boxstarter_path,
                'dest': remote_boxstarter_path
            }
        },
        {
            'name': 'Copy Boxstarter remove network adapter package to target machine',
            'win_copy': {
                'src': boxstarter_remove_adapter_path,
                'dest': remote_boxstarter_remove_adapter_path
            }
        },
        {
            'name': 'Copy Powershell Script to target machine',
            'win_copy': {
                'src': powershell_script_path,
                'dest': remote_powershell_script_path
            }
        },
        {
            'name': 'Execute Boxstarter package',
            'win_command': 'C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe -ExecutionPolicy ByPass -File ' + remote_powershell_script_path,
            'poll': '0',
            'async': '60'
        }
    ]

    playbook = {
        'name': 'Install necessary software',
        'hosts': 'cape_clients',
        'tasks': tasks
    }

    with open(playbook_path, 'w') as file:
        yaml.dump([playbook], file)

# parses the different packages provided by Chocolatey search to find best matches for each software
def parseSoftwareSearch(ansible_search_dir_path, software_dicts):
    files = os.listdir(ansible_search_dir_path)
    files = [f for f in files if f.endswith('.txt')]

    search_results = {}
    
    pattern = re.compile(r'^(.+?)_choco_search_results\.txt$')
    version_pattern = re.compile(r'^(\S+)\s+(\S+)\s')

    for filename in files:
        match = pattern.match(filename)
        if match:
            search_term = match.group(1)
            search_version = next((sd['version'] for sd in software_dicts if sd['name'] == search_term), None)

            with open(os.path.join(ansible_search_dir_path, filename), 'r', encoding='utf-16', errors='replace') as file:
                lines = file.readlines()
                packages = []

                for line in lines:
                    version_match = version_pattern.match(line.strip())
                    if version_match:
                        software = version_match.group(1)
                        version = version_match.group(2)
                        packages.append((software, version))

                # Use difflib to find the closest matching software name
                package_names = [(package[0], package[0].lower()) for package in packages]
                closest_matches = difflib.get_close_matches(search_term.lower(), [name[1] for name in package_names], n=len(package_names), cutoff=0.0)
                closest_match_name = None
                if closest_matches:
                    closest_match_name = next(name[0] for name in package_names if name[1] == closest_matches[0])

                # Filter packages for the closest match and get their versions
                if closest_match_name:
                    closest_match_packages = [package for package in packages if package[0] == closest_match_name]
                    closest_match_versions = [LooseVersion(package[1]) for package in closest_match_packages]

                    # Find the closest matching version
                    closest_match_version = None
                    if closest_match_versions and search_version is not None:
                        try:
                            search_loose_version = LooseVersion(search_version)
                            closest_match_version = max(v for v in closest_match_versions if v <= search_loose_version)
                        except:
                            print(f"[ERROR]: Invalid version string {search_version} for {search_term}")
                            continue

                # Print a warning if the closest version doesn't match the search version
                if closest_match_version and search_version is not None and str(closest_match_version) != search_version:
                    print(f"[WARNING]: Exact version {search_version} for {closest_match_name} not found. Using closest version: {closest_match_version}")

                # Store the result
                if closest_match_version:
                    for package in closest_match_packages:
                        if LooseVersion(package[1]) == closest_match_version:
                            search_results[search_term] = package
    return search_results

# generates Boxstarter package with required software
def createBoxstarterScript(parsed_search_results, boxstarter_path):
    script_lines = []
    script_lines.append(f"Update-ExecutionPolicy Unrestricted -Force")

    for software in parsed_search_results:
        script_lines.append(f"choco install {parsed_search_results[software][0]} --version {parsed_search_results[software][1]} -y")

    script_lines.append(f"C:\\boxstarter_remove_adapter.ps1")

    with open(boxstarter_path, 'w') as file:
        file.write('\n'.join(script_lines))

def main(config_path):
    config = loadConfig(config_path)

    with open(config['environment_json'], 'r') as file:
        environment_reqs = json.load(file)

    software_dicts = [{'name': software, 'version': version} for software, version in environment_reqs['softwares']]

    createAnsibleSearchPlaybook(config['search_playbook_path'], config['ansible_search_dir_path'], software_dicts)
    search_thread = threading.Thread(target=lambda: ansible_runner.run(private_data_dir='.', playbook=config['search_playbook_path'], inventory=config['inventory_path']))
    search_thread.start()

    parsed_search_results = parseSoftwareSearch(config['ansible_search_dir_path'], software_dicts)
    createBoxstarterScript(parsed_search_results, config['boxstarter_path'])
    createAnsibleInstallPlaybook(config['install_playbook_path'], config['boxstarter_path'], config['remote_boxstarter_path'], config['boxstarter_remove_adapter_path'], config['remote_boxstarter_remove_adapter_path'], config['powershell_script_path'], config['remote_powershell_script_path'])   
    install_thread = threading.Thread(target=lambda: ansible_runner.run(private_data_dir='.', playbook=config['install_playbook_path'], inventory=config['inventory_path']))
    install_thread.start()

    while True:
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect(('192.168.55.173', 9999))
            print('Boxstarter script has finished')
            s.close()
            break
        except socket.error as e:
            print('Boxstarter script is not done yet, retrying in 30 seconds...')
            time.sleep(30)

    search_thread.join()
    install_thread.join()

    time.sleep(5)

if __name__ == '__main__':
    main("env_setup.json")
