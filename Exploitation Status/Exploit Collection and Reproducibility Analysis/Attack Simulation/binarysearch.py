import subprocess
import requests
import json
import os
import sys

def extractMalscore(id):
    """
    This will extract the malscore from the JSON file when an attack is run. It will return the malscore value.
    """
    url = f'http://tjws-03.cse.nd.edu:8000/apiv2/tasks/get/report/{id}/json'
    print(url)
    headers = {'Authorization': 'Token c6ca22a6e54d162cc6d50b52e30a4629b95bc4c4'}
    r = requests.get(url, headers=headers)
    report = r.json()

    malscore = float(report['malscore'])

    return malscore

def pullRuns():
    """
    This will pull the latest run from the CAPEV2 server and return the id of the run + 1.
    """
    url = 'http://tjws-03.cse.nd.edu:8000/apiv2/tasks/list/100000/'
    headers = {'Authorization': 'Token c6ca22a6e54d162cc6d50b52e30a4629b95bc4c4'}
    r = requests.get(url, headers=headers)
    tasks = r.json()
    latest_id = 0

    for task in tasks['data']:
       # Grab the biggest task ID number and return it + 1
         if task['id'] > latest_id:
              latest_id = task['id']

    return latest_id + 1

def get_malscore_from_json(filename):
    """
    This will extract the malscore values from the JSON file when an attack is
    run. It will return a list of malscore values found in the JSON file.
    """
    cmd = ['jq', '.. | .malscore? | select(. != null)', filename]
    try:
            result = subprocess.check_output(cmd, stderr=subprocess.STDOUT)
            return result.decode('utf-8').strip().split("\n")  # This will return a list of malscore values.
    except subprocess.CalledProcessError as e:
            print(f"Error executing jq: {e.output.decode('utf-8')}")
            return None
    
def get_program_min_max(program_name, filepath=f"ansible/search_results/"):
    """
        Extracts and returns an array will all possible version numbers of a package. By
        default, the function will search the "ansible/search_results/" directory for a
        text file with the name of the program and "_choco_search_results.txt" appended to
        the end. This function will return an array of version numbers.
    """
    # Load the current content of the search from the text file
    with open(filepath + program_name.lower() + "_choco_search_results.txt", 'r', encoding='utf-16le') as file:
        data = file.read()

    # Split the data into a list of lines
    lines = data.splitlines()
    version_array = []

    # Parse through the lines and extract the lines with the package name
    for line in lines:
        line_split = line.split(" ")
        
        # Check the first element of the split line to see if it is the package name
        if line_split[0].lower() == program_name.lower():
            # If it is, then add the version number to the version array
            version_array.append(line_split[1])
        
    return version_array

def update_program_version(package_name, version, filepath='cve_requirements.json'):
    """
        Updates the version of a program in the cve_requirements.json file. By default, the
        function will find this file in the root directory of the project. This function will
        return nothing.
    """
    # Load the current content of the JSON file
    with open(filepath, 'r') as file:
        data = json.load(file)
    
    # Update the version of the program in the data if it exsists, otherwise add it to the data
    for software in data['softwares']:
        if software[0] == package_name:
            software[1] = str(version)
            break
    else:
        data['softwares'].append([package_name, str(version)])
    
    # Write the updated data back to the JSON file
    with open(filepath, 'w') as file:
        json.dump(data, file, indent=4)

def killBoxstarterPort():
    """
    Kills all instances of boxstarter and ansible running on the machine by searching all ports and
    killing the process running on that port.
    """
    print("Reseting boxstarter and ansible...")
    
    # Get all processes running on the machine
    cmd = ['sudo' , 'netstat', '-tulpn', "|", "grep", "LISTEN"]
    try:
        result = subprocess.check_output(cmd, stderr=subprocess.STDOUT)
        #result = result.decode('utf-8').strip().split("\n")
    except subprocess.CalledProcessError as e:
        print(f"Error executing netstat: {e.output.decode('utf-8')}")
        exit(1)
    
    # Parse through the results and kill all processes named boxstarter or ansib
    with open("netstat.txt", 'w') as file:
        file.write(str(result))

def update_json_log_name(name, exploits, filepath='cape-analyze-config.json'):
    """
    Updates the name of the run in the cape-analyze-config.json file. By default, the
    function will find this file in the root directory of the project. This function will
    return nothing.
    """
    # Load the current content of the JSON file
    with open(filepath, 'r') as file:
        data = json.load(file)

    # Update the name of the run in the data
    data['name'] = name

    # Update the exploits used in the data
    data['file_to_submit'] = exploits

    # Write the updated data back to the JSON file
    with open(filepath, 'w') as file:
        json.dump(data, file, indent=4)

def main():
    # DEFINE GLOBAL VARIABLES
    THRESHOLD = 2.0 # anything below 2.0 is 'green' in capev2's web analysis so i've chosen that as the malscore threshold for now
    RUN_NUMBER = pullRuns()

    if len(sys.argv) < 4:
        print("Usage: python3 script.py <runName> <exploit_name> <exploit_files>")
        sys.exit(1)
    
    # Check for -h flag
    if sys.argv[1] == "-h":
        print("Usage: python3 script.py <runName> <exploit_name> <exploit_file>")
        sys.exit(0)

    runName = sys.argv[1]
    package_name = sys.argv[2]
    exploit_files = sys.argv[3]

    # Find our programs version array
    # TODO: Possibly run a fucntion to pull the version list of that program
    version_array = get_program_min_max(package_name)

    # Set our low and high indecies
    low_index = 0
    high_index = len(version_array) - 1

    # Run our attack until we find the version that is vulnerable
    last_vulnerable_version = None
    while low_index <= high_index:
        mid_index = (low_index + high_index) // 2
        update_program_version(package_name, version_array[mid_index])
        
        print(f"Running attack with {package_name} version {version_array[mid_index]}")
        print(f"Current run number: {RUN_NUMBER}")

        # Update the output json log file name
        update_json_log_name(runName, exploit_files)

        # Run the attack
        os.system("ansible-playbook env-setup.yml -i hosts")
        filename = f'{RUN_NUMBER}_{runName}.json'
        
        # Get malscore
        malscore = extractMalscore(RUN_NUMBER)
        print(f"Malscore for {package_name} version {version_array[mid_index]}: {malscore}")
        
        # Check if the malscore is below the threshold
        if float(malscore) < THRESHOLD:
            last_vulnerable_version = version_array[mid_index]
            low_index = mid_index + 1
        else:
            high_index = mid_index - 1

        # Increment the run number
        RUN_NUMBER += 1

    if last_vulnerable_version is not None:
        print(f"Last vulnerable version of {package_name}: {last_vulnerable_version}")
    else:
        print(f"No vulnerable version of {package_name} found")


if __name__ == "__main__":
    main()