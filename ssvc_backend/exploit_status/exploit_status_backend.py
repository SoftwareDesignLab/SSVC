import os

import requests
import pandas as pd
from pathlib import Path

from requests import JSONDecodeError

from ssvc_backend.utils.ssvc_utils import get_json

# IMPORTANT NOTE: make sure you have openpyxl installed.
# Dict to cache decisions
# Key = CVE_ID value = exploit status decision
__DECISION_CACHE = dict()


def is_in_kev(cve_id, json_data=None):
    """
    Returns a boolean value of if a CVE ID is within the KEV. It is a super lightweight function
    that bases the logic off of the amount of results returned from the NVD api
    :param cve_id: CVE ID queried
    :return: boolean value
    """
    if json_data is None:
        request = requests.get(f"https://services.nvd.nist.gov/rest/json/cves/2.0?cveId={cve_id}&hasKev").json()
        # this is a value that will determine whether it should use the request return values
        # to determine if in kev due to checking the &hasKev method, otherwise will utilize
        # the cisaExploitAdd value that only exploits in the KEV will have.
        use_request = True
    else:
        request = json_data
        use_request = False

    cve = None
    if request['resultsPerPage'] > 0:
        vulnerabilities = request["vulnerabilities"]

        # The way that json.loads() loads the cves from the NIST json response
        # is all id'd by "CVE" into a dictionary of information.
        if len(vulnerabilities) == 0:
            return False

        cve_dict = vulnerabilities[0]
        # The way json
        cve = cve_dict["cve"]

        # Check if CVE is rejected
        status = cve["vulnStatus"]

        if status == "Rejected":
            return "REJECTED"
    if use_request:
        return request['resultsPerPage'] > 0
    else:
        if cve is None:
            return False

        return "cisaExploitAdd" in cve

def get_cwes_associated(cve_id, json_data=None):
    """
    A function that takes in a CVE ID and calls the NVD api and returns a list of CWEs
    that are associated.
    :param cve_id: id of the cve
    :param json_data: JSON Data that would be returned by a requests.get() call, this will avoid excessive calls to api
    :return: list of cwes associated with a cve
    """

    # if the data is not supplied, make request to the nvd database
    if json_data is None:
        request = requests.get(f"https://services.nvd.nist.gov/rest/json/cves/2.0?cveId={cve_id}").json()
    else:
        request = json_data

    cwe_ids = list()

    # check if the CVE-ID is valid.
    if request['resultsPerPage'] == 0:
        return cwe_ids

    # response is packaged into a vulnerabilities json obj
    # we will use the first index of the list because we're only looking up
    # one cve at a time.
    vulnerabilities = request["vulnerabilities"]
    cve = vulnerabilities[0]["cve"]  # access cve object of vulnerability

    if "weaknesses" not in cve:
        # if weaknesses aren't assigned to cve, return the empty list.
        return cwe_ids

    weaknesses = cve["weaknesses"]
    # loop through all weaknesses associated
    for weakness in weaknesses:
        # get information dictionary based on weakness
        ids = weakness["description"]
        for cwe in ids:
            # get "value" of CWE ID, this is how the API returns the ID.
            cwe_id = cwe["value"]
            cwe_ids.append(cwe_id)

    return cwe_ids


def is_poc(cwe_ids, working_dir=os.path.dirname(__file__)):
    """
    Function that interfaces with excel file that has information on CWE to POC research, and determines
    if CVE should associated be POC
    :param cwe_ids: cwes associated with CVE
    :param working_dir: Directory where the CWE to POC data file is
    :return: boolean of if poc
    """

    data = pd.read_excel(os.path.join(working_dir, "../possible-cwe-with-poc-examples.xlsx"), dtype=str)
    ids_only = [val.upper().replace("CWE-", "") for val in cwe_ids]

    # loop through all CWEs associated and determine if it can be a poc

    poc = len(data[data["CWE-ID"].isin(ids_only) & (data["Possible PoC"] == 'yes')]) == len(cwe_ids) and len(
        cwe_ids) > 0
    return poc


def get_exploit_status(cve_id, working_dir=os.path.dirname(__file__), print_status=True, json_data=None):
    """
    function to output the status of the cve provided. If the CVE is in kev it will output in KEV
    otherwise, the code will find the cwes associated with the cve
    :param cve_id:
    :param working_dir: Directory where the CWE to POC data file is
    :return: string value of exploit status
    """
    try:

        # Checking and returning the cached decision for the CVE_ID
        # global __DECISION_CACHE
        # if cve_id in __DECISION_CACHE:
        #     return __DECISION_CACHE[cve_id]
        if json_data is None:
            json_data = get_json(cve_id)
            if json_data is None:
                return None, None

        kev = is_in_kev(cve_id, json_data)

        if kev == "REJECTED":
            if print_status:
                print(f"{cve_id} is REJECTED, thus having no exploit status.")
            return "NONE", "Rejected CVE"
        elif kev:
            if print_status:
                print(f"{cve_id}'s exploit status is ACTIVE.")

            # cache and return the decision value
            __DECISION_CACHE[cve_id] = "ACTIVE"
            return "ACTIVE", "In KEV"
        elif get_exploit_collection(cve_id):
            if print_status:
                print(f"{cve_id}'s a POC due to Exploit Collection")
                __DECISION_CACHE[cve_id] = ("POC", "Exploit Collection")
                return "POC", "Exploit Collection"
        elif is_poc(get_cwes_associated(cve_id, json_data=json_data)):
            if print_status:
                print(f"{cve_id}'s exploit status is POC.")

            # cache and return decision value
            __DECISION_CACHE[cve_id] = ("POC", "CWEtoPOC")
            return "POC", "CWEtoPOC"
        else:
            if print_status:
                print(f"{cve_id}'s exploit status is NONE.")

            # cache and return decision value
            __DECISION_CACHE[cve_id] = ("NONE", "Nothing Found")
            return "NONE", "Nothing Found"
    except JSONDecodeError:
        if print_status:
            print("There was an error with your request, please ensure you inputted a valid CVE ID, and have not been flooding requests.")

        return None, None

def get_exploit_collection(cve_id):
    """
    Function to check for exploits collected via ND exploit collection
    @param cve_id:
    @return:
    """
    request = requests.get(f"https://api.cve.live/vulnerabilities/{cve_id}")

    if not request.status_code == 200:
        return False

    request_data = request.json()
    exploits = request_data["exploits"]

    return len(exploits) > 0

def main():
    id = input("enter cve id: ")
    get_exploit_status(id)


if __name__ == "__main__":
    main()
